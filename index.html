<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Optimisateur Robot Aspirateur Pathfinding</title>
    <style>
        body { font-family: 'Segoe UI', Arial, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; margin: 0; padding: 0;}
        .container {max-width: 1300px; margin: 30px auto; background: #fff; border-radius: 20px; box-shadow: 0 20px 60px rgba(0,0,0,0.1); padding: 30px;}
        h1 {text-align: center; background: linear-gradient(135deg, #667eea, #764ba2); -webkit-background-clip: text; -webkit-text-fill-color: transparent; font-size: 2.5rem; margin-bottom: 20px;}
        .controls {display: flex; flex-wrap: wrap; gap: 25px; margin-bottom: 20px;}
        .control-group {display: flex; flex-direction: column; gap: 7px; min-width: 200px;}
        label { font-weight: 600; color: #2c3e50; }
        input, select, button {padding: 10px; border: 2px solid #e3e8ef; border-radius: 10px; font-size: 1rem; background: white; transition: border 0.2s;}
        input:focus, select:focus { border-color: #667eea; }
        button { background: linear-gradient(135deg, #667eea, #764ba2); color: white; border: none; cursor: pointer; font-weight: 600;}
        button:hover { background: linear-gradient(135deg, #764ba2, #667eea);}
        .workspace { display: flex; gap: 25px; min-height: 600px;}
        .canvas-container {flex: 2; background: #fff; border-radius: 15px; box-shadow: 0 10px 30px rgba(0,0,0,0.1); position: relative; min-width: 600px;}
        canvas {display: block; background: #fafbfc; border-radius: 15px; border: 1px solid #e3e8ef; width: 100%; height: 600px;}
        .sidebar {flex: 1; background: #f5f6fa; border-radius: 15px; padding: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.07); min-width: 300px;}
        .zone-list { max-height: 180px; overflow-y: auto; margin-bottom: 15px;}
        .zone-item {display: flex; align-items: center; justify-content: space-between; background: #fff; border-radius: 8px; padding: 6px 12px; margin-bottom: 5px; font-size: 0.95em; border-left: 5px solid #667eea;}
        .stat-block {background: linear-gradient(135deg, #667eea, #764ba2); border-radius: 12px; color: white; padding: 15px; margin-top: 12px;}
        .stat-block div { margin: 6px 0; }
        .action-buttons button {margin: 7px 0; width: 100%;}
        @media (max-width: 900px) {.workspace { flex-direction: column; } .canvas-container, .sidebar { min-width: 0; }}
    </style>
</head>
<body>
<div class="container">
    <h1>ü§ñ Optimisateur Robot Aspirateur Pathfinding</h1>
    <div class="controls">
        <div class="control-group">
            <label>Forme g√©om√©trique</label>
            <select id="shapeType">
                <option value="freehand">Dessin libre</option>
                <option value="rectangle">Rectangle</option>
                <option value="circle">Cercle</option>
                <option value="line">Ligne droite</option>
            </select>
        </div>
        <div class="control-group">
            <label>Type d'√©l√©ment</label>
            <select id="elementType">
                <option value="zone">Zone de nettoyage</option>
                <option value="obstacle">Obstacle</option>
                <option value="wall">Mur/Cloison</option>
                <option value="charging">Station de recharge</option>
            </select>
        </div>
        <div class="control-group">
            <label>Priorit√©</label>
            <select id="priority">
                <option value="1">Tr√®s haute (Rouge)</option>
                <option value="2" selected>Haute (Orange)</option>
                <option value="3">Normale (Jaune)</option>
                <option value="4">Basse (Vert)</option>
                <option value="5">Tr√®s basse (Bleu)</option>
            </select>
        </div>
        <div class="control-group">
            <label>Niveau de salet√©</label>
            <select id="dirtLevel">
                <option value="1">Propre (1 L/m¬≤)</option>
                <option value="2">Peu sale (2 L/m¬≤)</option>
                <option value="3" selected>Moyennement sale (3 L/m¬≤)</option>
                <option value="5">Sale (5 L/m¬≤)</option>
                <option value="7">Tr√®s sale (7 L/m¬≤)</option>
            </select>
        </div>
        <div class="control-group">
            <label>Robot diam√®tre (m)</label>
            <input type="number" id="robotDiameter" value="1.5" min="0.4" max="3" step="0.01" style="width:90px;">
        </div>
        <div class="control-group">
            <label>√âchelle (px/m)</label>
            <input type="number" id="scale" value="50" min="10" max="200" style="width:80px;">
        </div>
    </div>
    <div class="workspace">
        <div class="canvas-container">
            <canvas id="canvas" width="900" height="600"></canvas>
        </div>
        <div class="sidebar">
            <div class="action-buttons">
                <button onclick="generateOptimizedPath()">üîÑ G√©n√©rer Trajectoire Optimis√©e</button>
                <button onclick="simulateRobot()">‚ñ∂Ô∏è Simuler Robot</button>
                <button onclick="clearAll()" style="background: linear-gradient(135deg,#e74c3c,#c0392b);">üóëÔ∏è Effacer Tout</button>
            </div>
            <h3>Zones / Obstacles :</h3>
            <div class="zone-list" id="zoneList"></div>
            <div class="stat-block">
                <div>Surface totale : <span id="totalArea">0 m¬≤</span></div>
                <div>Volume salet√© : <span id="totalDirt">0 L</span></div>
                <div>Distance trajet : <span id="totalDistance">0 m</span></div>
            </div>
        </div>
    </div>
</div>
<script>
let canvas = document.getElementById('canvas');
let ctx = canvas.getContext('2d');
let zones = [], obstacles = [], walls = [];
let chargingStation = null;
let currentZone = [];
let isDrawing = false, shapeStart = null, shapeMode = 'freehand';
let scale = 50, zoomLevel = 1, viewOffset = {x:0,y:0};
let ROBOT_CONFIG = {diameter:1.5};
let optimizedPath = [], simulationActive = false, simulationStep = 0;

const PRIORITY_COLORS = {1:'#e74c3c',2:'#f39c12',3:'#f1c40f',4:'#2ecc71',5:'#3498db'};

document.getElementById('scale').onchange = function() {
    scale = parseInt(this.value); redraw();
};
document.getElementById('robotDiameter').onchange = function() {
    ROBOT_CONFIG.diameter = parseFloat(this.value);
};
document.getElementById('shapeType').onchange = function() {
    shapeMode = this.value;
};

canvas.addEventListener('mousedown', handleMouseDown);
canvas.addEventListener('mousemove', handleMouseMove);
canvas.addEventListener('mouseup', handleMouseUp);

function getMousePosition(e) {
    let rect = canvas.getBoundingClientRect();
    return {x: (e.clientX-rect.left), y:(e.clientY-rect.top)};
}
function screenToWorld(pt) {
    return {x:(pt.x-viewOffset.x)/zoomLevel, y:(pt.y-viewOffset.y)/zoomLevel};
}
function worldToScreen(pt) {
    return {x:pt.x*zoomLevel+viewOffset.x, y:pt.y*zoomLevel+viewOffset.y};
}
function getPolygonCenter(points) {
    let cx=0,cy=0;
    for(let p of points){cx+=p.x;cy+=p.y;}
    return {x:cx/points.length,y:cy/points.length};
}
function getDistance(a,b) {
    let dx=a.x-b.x,dy=a.y-b.y;
    return Math.sqrt(dx*dx+dy*dy)/scale;
}
function getPolygonArea(points){
    let a=0;
    for(let i=0;i<points.length;i++){
        let j=(i+1)%points.length;
        a += points[i].x*points[j].y-points[j].x*points[i].y;
    }
    return Math.abs(a/2)/(scale*scale);
}

function redraw() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawGrid();
    for(let wall of walls){
        ctx.strokeStyle = '#34495e'; ctx.lineWidth = 3/zoomLevel;
        drawPolygon(wall.points, false);
    }
    for(let ob of obstacles){
        ctx.fillStyle='rgba(231,76,60,0.6)'; ctx.strokeStyle='#e74c3c'; ctx.lineWidth=2/zoomLevel;
        drawPolygon(ob.points,true);
    }
    for(let zone of zones){
        let color = PRIORITY_COLORS[zone.priority];
        ctx.fillStyle = color+'33'; ctx.strokeStyle = color;
        ctx.lineWidth = 2/zoomLevel;
        drawPolygon(zone.points,true);
        let c = getPolygonCenter(zone.points);
        ctx.fillStyle='#2c3e50'; ctx.font=`${12/zoomLevel}px Arial`;
        ctx.textAlign='center';
        ctx.fillText(`${zone.dirtLevel}L/m¬≤`,c.x,c.y);
    }
    if(chargingStation){
        ctx.save();
        ctx.fillStyle="#27ae60";
        ctx.beginPath();
        ctx.arc(chargingStation.x,chargingStation.y,15/zoomLevel,0,2*Math.PI);
        ctx.fill();
        ctx.strokeStyle="#145a32";
        ctx.lineWidth = 4/zoomLevel;
        ctx.stroke();
        ctx.restore();
    }
    if(optimizedPath.length>1) drawPath(optimizedPath);
    if(simulationActive && simulationStep < optimizedPath.length) drawRobot(optimizedPath[simulationStep]);
}
function drawGrid() {
    ctx.save();
    ctx.strokeStyle="#ecf0f1"; ctx.lineWidth=1/zoomLevel;
    let gridSize=scale;
    let w=canvas.width, h=canvas.height;
    for(let x=0; x<w; x+=gridSize*zoomLevel) {
        ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
    }
    for(let y=0; y<h; y+=gridSize*zoomLevel) {
        ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
    }
    ctx.restore();
}
function drawPolygon(points, fill) {
    if(points.length==0) return;
    ctx.beginPath();
    ctx.moveTo(points[0].x,points[0].y);
    for(let i=1;i<points.length;i++) ctx.lineTo(points[i].x,points[i].y);
    ctx.closePath();
    fill?ctx.fill():ctx.stroke();
}
function drawPath(path) {
    if (path.length < 2) return;
    ctx.save();
    ctx.strokeStyle = "#8e44ad";
    ctx.lineWidth = 4 / zoomLevel;
    ctx.setLineDash([]);
    ctx.beginPath();
    ctx.moveTo(path[0].x, path[0].y);
    for (let i = 1; i < path.length; i++) {
        ctx.lineTo(path[i].x, path[i].y);
    }
    ctx.stroke();
    ctx.restore();
}
function drawRobot(pos) {
    ctx.save();
    ctx.fillStyle="#2980b9";
    ctx.beginPath();
    ctx.arc(pos.x,pos.y,ROBOT_CONFIG.diameter*scale/2,0,2*Math.PI);
    ctx.fill();
    ctx.strokeStyle="#154360";
    ctx.lineWidth=3/zoomLevel;
    ctx.stroke();
    ctx.restore();
}
function drawPreviewShape(start,end,type){
    let pts = createGeometricShape(start,end,type);
    if(!pts.length) return;
    ctx.save();
    ctx.strokeStyle='#3498db'; ctx.lineWidth=2/zoomLevel;
    ctx.setLineDash([5/zoomLevel,5/zoomLevel]);
    ctx.fillStyle='rgba(52,152,219,0.2)';
    ctx.beginPath();
    ctx.moveTo(pts[0].x,pts[0].y);
    for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x,pts[i].y);
    ctx.closePath(); ctx.fill(); ctx.stroke();
    ctx.restore();
}
function drawCurrentZone() {
    if(currentZone.length==0) return;
    ctx.save();
    ctx.strokeStyle='#3498db'; ctx.lineWidth=2/zoomLevel;
    ctx.setLineDash([5/zoomLevel,5/zoomLevel]);
    ctx.beginPath();
    ctx.moveTo(currentZone[0].x,currentZone[0].y);
    for(let i=1;i<currentZone.length;i++) ctx.lineTo(currentZone[i].x,currentZone[i].y);
    ctx.stroke(); ctx.setLineDash([]); ctx.restore();
}

function handleMouseDown(e) {
    let world = screenToWorld(getMousePosition(e));
    let elementType = document.getElementById('elementType').value;
    let shapeType = document.getElementById('shapeType').value;
    if(elementType === "charging") {
        chargingStation = {x:world.x, y:world.y};
        redraw();
        return;
    }
    shapeMode = shapeType;
    if(['rectangle','circle','line'].includes(shapeMode)){
        shapeStart = world;
        isDrawing = true;
    } else {
        isDrawing = true; currentZone = [world];
    }
}
function handleMouseMove(e) {
    if(!isDrawing) return;
    let world = screenToWorld(getMousePosition(e));
    if(shapeMode==="freehand") {
        currentZone.push(world);
        redraw();
        drawCurrentZone();
    } else if(['rectangle','circle','line'].includes(shapeMode)&&shapeStart) {
        redraw();
        drawPreviewShape(shapeStart,world,shapeMode);
    }
}
function handleMouseUp(e) {
    if(!isDrawing) return;
    isDrawing = false;
    let world = screenToWorld(getMousePosition(e));
    let elementType = document.getElementById('elementType').value;
    let priority = parseInt(document.getElementById('priority').value);
    let dirtLevel = parseInt(document.getElementById('dirtLevel').value);
    if(['rectangle','circle','line'].includes(shapeMode)&&shapeStart){
        let shape = createGeometricShape(shapeStart,world,shapeMode);
        if(shape&&shape.length>2) addShapeToLayer(shape,elementType,priority,dirtLevel);
        shapeStart=null;
    } else if(shapeMode==="freehand"&&currentZone.length>2){
        addShapeToLayer(currentZone,elementType,priority,dirtLevel);
    }
    currentZone=[];
    redraw();
}
function createGeometricShape(start,end,type){
    let pts=[];
    switch(type){
        case'rectangle':
            pts.push(
                {x:start.x,y:start.y},{x:end.x,y:start.y},
                {x:end.x,y:end.y},{x:start.x,y:end.y}
            );break;
        case'circle':
            let cx=(start.x+end.x)/2, cy=(start.y+end.y)/2;
            let r = Math.max(Math.abs(start.x-end.x),Math.abs(start.y-end.y))/2;
            for(let i=0;i<32;i++){
                let a = (i/32)*2*Math.PI;
                pts.push({x:cx+Math.cos(a)*r,y:cy+Math.sin(a)*r});
            }break;
        case'line':
            let dx=end.x-start.x,dy=end.y-start.y,len=Math.sqrt(dx*dx+dy*dy);
            if(len>0){
                let ux=-dy/len*5, uy=dx/len*5;
                pts.push(
                    {x:start.x+ux,y:start.y+uy},{x:end.x+ux,y:end.y+uy},
                    {x:end.x-ux,y:end.y-uy},{x:start.x-ux,y:start.y-uy}
                );
            }break;
    }
    return pts;
}
function addShapeToLayer(pts,elementType,priority,dirtLevel){
    if(elementType==="zone"){
        zones.push({points:[...pts],priority:priority,dirtLevel:dirtLevel});
    }else if(elementType==="obstacle"){
        obstacles.push({points:[...pts]});
    }else if(elementType==="wall"){
        walls.push({points:[...pts]});
    }
    updateZoneList();
    updateStats();
}
function updateZoneList(){
    let html="";
    zones.forEach((z,i)=>{
        html+=`<div class="zone-item" style="border-left-color:${PRIORITY_COLORS[z.priority]}">
            Zone ${i+1} | Priorit√© ${z.priority} | ${z.dirtLevel}L/m¬≤</div>`;
    });
    document.getElementById("zoneList").innerHTML=html;
}
function updateStats(){
    let totalA=0, totalD=0;
    for(let z of zones){
        totalA += getPolygonArea(z.points);
        totalD += getPolygonArea(z.points)*z.dirtLevel;
    }
    document.getElementById("totalArea").textContent=totalA.toFixed(1)+" m¬≤";
    document.getElementById("totalDirt").textContent=totalD.toFixed(1)+" L";
}
function clearAll(){
    zones=[]; obstacles=[]; walls=[]; chargingStation=null; optimizedPath=[];
    updateZoneList(); updateStats(); redraw();
}

// --- Couverture de rectangle ---
function generateCoveragePathForRectangle(rectPoints, robotDiameter) {
    let minX = Math.min(...rectPoints.map(p => p.x));
    let maxX = Math.max(...rectPoints.map(p => p.x));
    let minY = Math.min(...rectPoints.map(p => p.y));
    let maxY = Math.max(...rectPoints.map(p => p.y));
    let bandSpacing = robotDiameter * scale * 0.98;
    let path = [];
    let direction = 1;
    for (let y = minY + bandSpacing / 2; y < maxY; y += bandSpacing) {
        let x1 = minX, x2 = maxX;
        if (direction === 1) {
            path.push({ x: x1, y: y });
            path.push({ x: x2, y: y });
        } else {
            path.push({ x: x2, y: y });
            path.push({ x: x1, y: y });
        }
        direction *= -1;
    }
    return path;
}

// --- Grille/Pathfinding ---
// Grille fine, obstacles/murs √©largis selon rayon robot
function makeGrid(cellSize=10){
    let width = canvas.width, height = canvas.height;
    let cols = Math.ceil(width / cellSize), rows = Math.ceil(height / cellSize);
    let grid = [];
    for(let y=0; y<rows; y++){
        let row = [];
        for(let x=0; x<cols; x++) row.push(0);
        grid.push(row);
    }
    let markPolygon = (poly) => {
        let minX=Math.min(...poly.map(p=>p.x)), maxX=Math.max(...poly.map(p=>p.x));
        let minY=Math.min(...poly.map(p=>p.y)), maxY=Math.max(...poly.map(p=>p.y));
        let radius = Math.ceil((ROBOT_CONFIG.diameter * scale)/2/cellSize);
        for(let y=Math.floor(minY/cellSize)-radius; y<=Math.ceil(maxY/cellSize)+radius; y++){
            for(let x=Math.floor(minX/cellSize)-radius; x<=Math.ceil(maxX/cellSize)+radius; x++){
                let cx=x*cellSize+cellSize/2, cy=y*cellSize+cellSize/2;
                if(pointInPolygon({x:cx, y:cy}, poly)){
                    for(let dy=-radius; dy<=radius; dy++)
                        for(let dx=-radius; dx<=radius; dx++)
                            if(grid[y+dy] && grid[y+dy][x+dx]!==undefined)
                                grid[y+dy][x+dx]=1;
                }
            }
        }
    };
    for(let ob of obstacles) markPolygon(ob.points);
    for(let wall of walls) markPolygon(wall.points);
    return {grid,cellSize,cols,rows};
}
function pointInPolygon(point, vs) {
    let x = point.x, y = point.y, inside = false;
    for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
        let xi = vs[i].x, yi = vs[i].y;
        let xj = vs[j].x, yj = vs[j].y;
        let intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi + 0.00001) + xi);
        if (intersect) inside = !inside;
    }
    return inside;
}

// --- A* Pathfinding ---
function astar(start, end, gridObj) {
    let {grid,cellSize,cols,rows} = gridObj;
    let node = (x,y,parent,g,h) => ({x,y,parent,g,h,f:g+h});
    let startCell = {x: Math.floor(start.x/cellSize), y: Math.floor(start.y/cellSize)};
    let endCell = {x: Math.floor(end.x/cellSize), y: Math.floor(end.y/cellSize)};
    let open = [node(startCell.x,startCell.y,null,0,
        Math.abs(startCell.x-endCell.x)+Math.abs(startCell.y-endCell.y))];
    let closed = new Set();
    let key = (x,y)=>`${x},${y}`;
    let dirs = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
    while(open.length){
        open.sort((a,b)=>a.f-b.f);
        let cur = open.shift();
        if(cur.x===endCell.x && cur.y===endCell.y){
            let path = [];
            while(cur){
                path.push({x:cur.x*cellSize+cellSize/2, y:cur.y*cellSize+cellSize/2});
                cur=cur.parent;
            }
            return path.reverse();
        }
        closed.add(key(cur.x,cur.y));
        for(let [dx,dy] of dirs){
            let nx=cur.x+dx, ny=cur.y+dy;
            if(nx<0||ny<0||nx>=cols||ny>=rows) continue;
            if(grid[ny][nx]===1) continue;
            if(closed.has(key(nx,ny))) continue;
            let ng = cur.g + ((dx*dx+dy*dy)===2?1.41:1);
            let nh = Math.abs(nx-endCell.x)+Math.abs(ny-endCell.y);
            let n = node(nx,ny,cur,ng,nh);
            if(!open.some(o=>o.x===nx&&o.y===ny&&o.f<=n.f)) open.push(n);
        }
    }
    // Pas de chemin trouv√©
    return [start,end];
}

// --- G√©n√©ration du chemin ---
function generateOptimizedPath() {
    if (!chargingStation || zones.length === 0) {
        alert("Ajoute une station de recharge et au moins une zone !");
        return;
    }
    let path = [];
    let current = { x: chargingStation.x, y: chargingStation.y };
    let robotDiameter = ROBOT_CONFIG.diameter;
    let gridObj = makeGrid(10); // Grille fine
    zones.forEach(zone => {
        if (zone.points.length === 4) {
            let coverage = generateCoveragePathForRectangle(zone.points, robotDiameter);
            let seg = astar(current, coverage[0], gridObj);
            for(let p of seg) path.push(p);
            for (let i=0;i<coverage.length-1;i++) path.push(coverage[i+1]);
            current = coverage[coverage.length - 1];
        } else {
            let center = getPolygonCenter(zone.points);
            let seg = astar(current, center, gridObj);
            for(let p of seg) path.push(p);
            current = center;
        }
    });
    let ret = astar(current, { x: chargingStation.x, y: chargingStation.y }, gridObj);
    for(let p of ret) path.push(p);
    optimizedPath = path;
    document.getElementById("totalDistance").textContent = computeTotalPathDistance(path).toFixed(2) + " m";
    redraw();
    alert("Trajectoire de couverture g√©n√©r√©e !");
}
function computeTotalPathDistance(path){
    let d=0;
    for(let i=1;i<path.length;i++) d+=getDistance(path[i-1],path[i]);
    return d;
}

function simulateRobot(){
    if(!optimizedPath.length){alert("G√©n√®re d'abord la trajectoire !");return;}
    simulationActive=true; simulationStep=0;
    function step() {
        if(!simulationActive) return;
        redraw();
        simulationStep++;
        if(simulationStep<optimizedPath.length) setTimeout(step,30);
        else simulationActive=false;
    }
    step();
}

redraw();
updateZoneList();
updateStats();
window.generateOptimizedPath = generateOptimizedPath;
window.simulateRobot = simulateRobot;
window.clearAll = clearAll;
</script>
</body>
</html>
